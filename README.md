# اصول solid

## Single Responsibility Principle
این اصل بیان میکند که هر کلاس یک و فقط یک `دلیل` برای تغییر داشته باشد. به توضیحی دیگر یک کلاس فقط باید تنها یک کار انجام دهد.

## Open Closed Principle
بیان میکند که کلاس ها باید برای گسترش باز باشند و برای تغییر بسته باشند. یعنی اگر ما بخواهیم یک قابلیت جدید یا یک نوع جدید از قابلیت های قبلی را به ان کلاس اضافه کنیم باید امکان ایجاد این تغییرات بدون نیاز به تغییر در کدهای قبلی باشد و تنها نیاز باشد ما کد جدید اضافه کنیم و نه کاملا کلاس را از اول بنویسیم.

## Liskov Substitution Principle
بیان میکند اگر کلاس پدر یک ویژگی داشته باشد کلاس فرزند هم باید ان ویژگی را داشته باشد. به عبارتی دیگر شی از جنس فرزند باید بتواند مانند کلاس پدر عمل بکند و در غیر این صورت دیگر رابطه ارثبری برقرار نیست.

## Interface Segregation Principle
یک شی نباید مجبور باشد که یک interface که نیازی به ان ندارد را پیاده سازی بکند. به عبارتی دیگر کاربر نباید مجبور شود که به توابعی که از انها بهره نمیبرد وابسته شود.

## Dependency Inversion Principle
موجودیت ها باید وابسته به موجودیت های انتزاعی باشند نه موجودیت های کاملا واقعی و پیاده سازی شده. به عبارتی دیگر کلاس های سطح بالا نباید به کلاس های سطح پایین که موارد پیاده سازی در انها وجود دارد وابسته شوند زیرا با کوچکترین تغییر نیاز داریم دوباره انها کامپایل و مستقر شوند.

# در کجا استفاده میشوند
این اصول در همه بخش های مهندسی نرم افزار استفاده میشوند و محدود به یک بخش خاص نیستند زیرا این موارد یک سری اصول هستند که رعایت انها در هر بخش باعث خوانایی بیشتر طراحی خواهد شد. به طور مثال رعایت این اصول در مهندسی نیازمندی باعث میشوند بهتر نیازمندی ها را تشخیص دهیم و user story  های بهتری تولید کنیم و از این طریق به طراحی بهتر برسیم. 
علاوه بر این استفاده از این اصول در استقرار هم باعث ساده تر شدن scale اپ و موارد همچنینی خواهد شد.

# آیا TDD با برنامه نویسی عمومی تناقض دارد؟
خیر - نوشتن تست بعد یا قبل کد در تناقض کامل با یکدیگر نیست صرفا به دلیل نوشتن تست قبل از کد میتوانیم دقیق تر روی کد تمرکز کنیم و از ابتدا کد تمیزتر بنویسیم و به سرعت مشکلات کد را متوجه بشویم. علاوه بر این سپردن نوشتن کد به اینده امکا اهمال کاری و ننوشتن کلی کد را دارد پس بهتر از این روش استفاده شود ولی اجباری وجود ندارد و هر دو روش در یک راستا حرکت میکنند.
در چرخه عمومی ایجاد نرم افزار، معمولاً پس از طراحی و پیاده سازی نرم افزار، فاز تست انجام می شود. در این فاز، تست کنندگان برای یافتن ایرادات و باگ ها در کد نوشته شده تست های مختلف را انجام می دهند. 
از طرفی، روش توسعه مبتنی بر تست (TDD) یک روش توسعه نرم افزار است که در آن توسعه دهندگان ابتدا تست ها را می نویسند و سپس کدی را می نویسند که این تست ها را پاس می کند. این رویکرد به توسعه دهندگان اجازه می دهد تا به طور مداوم و مرتب کد خود را بررسی و اصلاح کنند، و همچنین باعث می شود تا از همان ابتدا تست ها در پروسه توسعه نرم افزار جایگزین شوند.
پس این دو رویکرد تناقضی با یکدیگر ندارند، بلکه بسته به شرایط و نیازهای خاص پروژه، می توان از هر یک استفاده کرد. در برخی موارد، ممکن است روش TDD به دلیل فراهم کردن بازخورد فوری و دائمی در مورد کیفیت کد، انتخاب بهتری باشد. در موارد دیگر، ممکن است رویکرد تست کلاسیک مناسب تر باشد


## آیا در مسيله مربع و مستطیل بدون نیاز به تغییر ابعاد مستطیل میتوان مربع را از مستطیل ارث بری کرد؟
بله، در این حالت می توانیم مربع را از مستطیل به ارث ببریم، اما باید به چند نکته مهم توجه کنیم.

اصل جایگزینی لیسکوف (LSP) یکی از اصول SOLID است که می گوید زیرکلاس ها باید قادر باشند جایگزین سوپر کلاس های خود شوند بدون اینکه رفتار برنامه تغییر کند. در حالتی که ابعاد یک مستطیل قابل تغییر باشند، این اصل نقض می شود اگر مربع را به عنوان یک زیرکلاس از مستطیل در نظر بگیریم، زیرا تغییر طول یا عرض یک مستطیل نباید تغییراتی در عرض یا طول دیگر ایجاد کند، اما در مورد مربع، تغییر در یکی از ابعاد باید تغییر متناسبی در دیگری ایجاد کند.

اما در حالتی که ابعاد مستطیل ثابت باشند و تغییر نکنند، می توانیم مربع را به عنوان یک زیرکلاس از مستطیل در نظر بگیریم. در این حالت، همه خصوصیات و رفتارهای مربع با مستطیل همخوانی دارند و مربع می تواند به صورت قابل اعتماد جایگزین مستطیل شود. هر دو دارای دو طول و عرض هستند و مساحت آنها با همان روش محاسبه می شود. با این حال، این رویکرد معمولاً توصیه نمی شود زیرا در عمل، معمولاً نیاز است که ابعاد یک شیء قابل تغییر باشند و این رویکرد ممکن است محدودیت هایی را ایجاد کند..
